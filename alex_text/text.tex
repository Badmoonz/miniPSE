\documentclass[a4paper,14pt]{article}

\usepackage{amsmath,amsfonts,amssymb,amsthm,epsfig,epstopdf,titling,url,array}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
%\usepackage[T2A]{fontenc}
\usepackage{amsmath,amssymb,amsthm,amscd,amsfonts,graphicx}
\usepackage[14pt]{extsizes}

\usepackage{cleveref}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,snakes,automata,backgrounds,petri}

\newcommand{\workflow}{\textit{workflow}}
\newenvironment{definition}[1]{
\hskip \labelsep {\bfseries #1} \it}

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{corollary}{Вывод}



\begin{document}
\textwidth 15.5cm
\topmargin -1cm
\parindent 1cm
\textheight 24cm
\parskip 1.5mm



\section{Введение}
\subsection*{Цель работы}
Целью работы являляется построение модели workflow, ориентированного  на решение научно-инженерных задач в распределённой среде. И разработка методов и инструментов анализа этой модели.
 Под инженерными и научными задачами в данном контексте мы понимаем 
мультидисциплинарные задачи в форме так называемых композитных приложений. В работе мы рассматриваем примеры задач обработки и анализа данных, например построения  суррогатных моделей , и задач многодисциплинарной оптимизации. Наиболее распространенным подходом к представлению таких композитных приложений является формализм потока работ, или workflow.

Под workflow подразумевается формальное представление (модель) некоторого процесса, включающее в себя:
\begin{enumerate}
\item[-] Описание операций, из которых состоит процесс.
\item[-] Описание исполнителей, которые выполняют указанные операции.
\item[-] Описание зависимостей между операциями, а именно :
\begin{enumerate}
\item[•] потоков управления, которые определяют последовательность выполнения операций 
\item[•] потоков данных, которые
определяют передачу информации между исполнителями.
\end{enumerate}
\end{enumerate}


Для выполнения задач, поставленных с помощью workflow, требуется система управления или исполнения( Workflow Managment system, WFMS)). WFMS состоит из набора программных
компонентов, предназначенных для:
\begin{enumerate}
\item[•] хранения и интерпретации описаний
процессов 
\item[•] создания и управления экземплярами запущенных процессов
\item[•] организации их взаимодействия с участниками
процесса и внешними приложениями.
\end{enumerate}



\subsection*{Отличие научных workflow от бизнес-процессов}
  Исторически данный подход широко использовался для описания бизнес-процессов. В данной работе мы рассматриваем научно-инженерные задачи, приведём их некоторые характерные особенности:
 
\begin{enumerate}
\item[-] Научно-инженерные задачи требуют существенных вычислительных затрат.
\item[-] Научно-инженерные задачи работаютт с большими объёмами данных.
\item[-] Зачастую бывает  необходимо одинаковым образом обрабатывать разные данные.
\item[-]  Ввиду перечисленных выше трёх пунктов, задачи согут быть ресурсоёмеими, поэтому имеет смысл использовать распределённую средее.
\item[-]  характерна декомпозиция,. т.е вложенная иерархия workflow.
\end{enumerate}

Указанные особенности научных вычислительных процессов определяют требования, которым должна удовлетворять WFMS, подходящая для
описания и выполнения данных процессов в виде сценариев. Традиционные WFMS, рассчитанные на работу с бизнес-процессами, в подавляющем большинстве не подходят для решения научных задач, о чём будет сказано позже Поэтому, требуется разработка новых, научных WFMS, с одной стороны опирающихся на сформировавшуюся workflow-методологию, а с другой стороны — специально рассчитанных на требования научных приложений.

\section{Обзор существующих моделей и подходов к представлению Workflow}

Свою работу мы начали с изучения уже существующих систем
\subsection*{Модели управления запуском Workflow}
  Все моделей управления workflow можно разделить на два класса: модели ориентированные на потоки данных(data-flows) и модели ориентированные на потоки управления(control-flows). Оба класса определяют взаимодействие между отдельными задачами-компонентами workflow, но различаются принципами реализации этого взаимодействия.  \\
  В workflow, основанных на принципе потока данных, связи между элементами workflow  представляет передачу управления от одного задания следующему. Это позволяет формировать внутри workflow такие типы структур, как: последовательное выполнение, параллельное выполнение, циклы и условные переходы.\\ 
  В workflow, основанные на принципе data-flow, зависимости между элементами workflow, определяют направления потоков данных, поэтому последовательность выполнения может задаваться неявно.
 
Так же существуют гибридные системы управления workflow, сочетающие в себе принципы обоих приведённых выше классов. Гибридные системы поддерживают оба типа зависимостей между компонентами workflow, но  один из типов, как правило, является доминирующим, а другой используется при необходимости  в особых случаях. Например, в data-flows системе такой как Triana, возникают ситуации, когда необходимо последовательно связать задачу, не производящую никакие данные, с задачей, не  требующей данных на вход. В таком случае, на этом участке будет использован переход к control-flow зависимости.\\
  
\subsection*{Представление Workflow}
За время существования методологии workflow возникло несколько различных подходов их формального описания. Например:
\begin{enumerate}
\item[•] Использование скриптовых языков.\\
 Скриптовые языки в качестве средства представления сценариев могут быть удобны пользователям(инженерам или исследователям), имеющим опыт программирования. Но не смотря на высокий уровень скриптовых языков и относительную простоту, они не достаточно наглядны и интуитивны.\\
\item[•] ориентированный ациклические графы(DAG);\\
 + Направленных ациклических графов — простота структуры и реализации.
  Но есть и недостатки:\\
  - они накладывают ограничения на типы сценариев — например, нельзя явно задать циклы без применения дополнительных конструкций, уже не связанных с графовым представлением. Неестественность в описании задач, имеющих итеративную природу, например задач оптимизации. \\
\item[•] сети Петри.\\ 
 Сети Петри — графический язык. Поэтому они
интуитивно понятны и легки для изучения. Их графическая природа
также удобна для взаимодействия с конечными пользователями. К тому же сети Петри были хорошо исследованы м отличаются наличием большого числа методов анализа. И это их ценное преимущество с точки зрения использования для
описания сценариев — данные методы могут быть использованы для доказательства различных свойств (выполнимости, нахлжденния  мертвых переходов и т. д.) и для вычисления характеристик выполнения сценариев (время отклика, время ожидания, степень занятости и пр.).
\end{enumerate}

В чистом виде не подходят, и мы применяем некоторый гибридный подход.
 Как уже было сказано, в научных приложениях часто все необходимые действия сводятся к различным операциям над данными, т. е. в подобных процессах потоки управления и потоки данных совпадают. Поэтому нет необходимости вводить специальные элементы языка для описания логических конструкций, а достаточно просто обеспечить средства объединения элементарных модулей обработки данных в сеть. Каждый модуль имеет один или несколько входов и выходов, дуги сети соответствуют соединениям выхода одного
модуля с входом другого, по которым осуществляется передача данных
между модулями. Как только на вход модуля поступили все необходимые данные, происходит запуск программного кода модуля, который производит обработку входных данных, после чего полученные результаты (выходные данные) помещаются в выходы модуля и передаются по соединениям на вход других модулей. 
 
 
\section{Формальное описание разрабатываемой модели Workflow}


\subsection{Элементы workflow}
Описываемая модель оперирует двумя понятиями : блок и связи.
\subsection{Блок}
Блок в нашей модели является единице исполнения workflow, например , блое может быть представлять некоторый программный модуль. Блок описывается не детерминированным конечным автоматом.

\begin{definition}{Определение: Конечный автомат блока} Конечным автоматом блока называется набор $M = (\Sigma, I, O \cup {done}, T, s_{0})$ , где
\begin{enumerate}
\item[-] $\Sigma$ -набор конечных состояния,
\item[-] $I$ - непустой набор доступных входных портов блока,
\item[-] $O$ - набор доступных выходных портов блока,
\item[-] $I \bigcap O = \varnothing$ - 
\item[-] $s_{0} \in \Sigma$ - начальное состояние,
\item[-] $T: \Sigma \times (2^{I} \backslash \lbrace \varnothing \rbrace) \rightarrow  2^{\Sigma \times (2^{O} \cup \lbrace done \rbrace)}$ отображение сопоставляющее каждому состоянию и набору входных портов набор состояний с соответствующим набором выходных портов.
\end{enumerate}
\end{definition}
\subsection{Связи} 
В нашей моделе связи - абстракция передачи данных.

В рассматриваемой модели мы абстрагируемся от типизации данных передаваемых между блоками, считая что для любых двух соединённых блоков типы данных для каждой пары соединённых портов совместимы. Поэтому мы сразу можем представлять передаваемые по связям данные как сигналы.

\subsection{Представление workflow}

 Мультиграф связей workflow $WFG =(A, D)$ состоит из набора блоков $A$ и набора связей D, соединяющих блоки через порты.
 При этом в состав набора блоков всегда $A$ входят два уникальных абстрактных блока \textit{Source} и \textit{Stock}, вводимых для задания точек запуска и завершения workflow.
 Формально связь $d \in D$ представима в виде четвёрки $(s, sp, t, tp)$, где $s,t in A$ - идентификаторы входной и выходных блоков,  $sp \in out(s),tp \in in(p)$ - выходной и входной порты соответствующих блоков. 
 
Отметим некоторые свойства, связанные со связями:
\begin{enumerate}
\item[-] Связь может быть установлена только между выходным портом одного блока и входным портом другого блока или самого себя.
\item[-] Связи могут быть построены как из одного выходного порта ко многим входным, так и из нескольких выходных в один входной порт.
\item[-]ОБратим внимание, что если блок испускает сигнал по какому либо порту, то сигнал распространяется по всем связям исходящих из этого порта до конечного порта назначения, таким образом возможно порождаются конкурирующие потоки.
\item[-] Входные и выходные порты блоков могут оставаться неподключенными.
\end{enumerate} 
 
 
 
 
\subsection{Возможные ошибки при проектировании}
Для решения инженерной задачи должна быть составлена соответствующая  И одной из целей работы было нахождение ошибок до начала запуска.

Рассмотрим возможные ошибки при построении workflow, которые можно выявить из структуры workflow на этапе проектирования. 

Так как мы подразумеваем возможность асинхронной работы программных модулей на отдельных участках workflow, то как и в многопоточных приложениях возможно возникновение \textit{состояние гонки}(Race condition). 
В контексте нашей модели workflow состояние гонки бывает двух типов:
\begin{enumerate}
\item[•] Случай, когда на один входной порт приходят два сигнала одновременно.
\item[•] Когда на входные порты блока одновременно приходит такой набор сигналов, что что существует неоднозначность запуска.
Потенциально возможно в блоках, у которых есть состояния
$b = (S, \Sigma,\Lambda, T, s_{0});\\
 \exists s \in S , \exists in1, in2 \in 2^{\Sigma} :  T(s, in1) \neq \varnothing \bigwedge T(s, in2) \neq \varnothing$
 
Голодание  - к концу работы workflow, остаются необработанные данные(сигналы)
\end{enumerate}

\section{Методы анализа модели workflow}

Алгоритм моделирования работы workflow будет использоваться для нахождения структурных ошибок в workflow, и для построения графа состояний workflow, который будет использоваться при дальнейшем анализе. 

Так как мы хотим получить workflow, свободный от  ошибок, связанных  с состоянием гонки, то, не зная априори время работы каждого блока, а только может быть некоторую оценочную её величину, то можем  
Моделировать работу workflow будем в дискретном режиме.


Понятие разбиения потока вводится для формализации конкуренции между сигналами, распространяющимися по связям внутри workflow.

\begin{definition}{Опредление: Разбиение потока}
Разбиением потока назовём пару (fork, splitting), где fork - имя блока, которой испустившего набор сигналов, а splitting - кортеж состоящий из n элементов, где n - число исходящих от блока сигналов. А каждый элемент кортежа может быть либо 1, либо 0, либо другим разбиением. 
\end{definition}

\begin{definition}{Опредление: Нулевое разбиение}
Под нулевым разбиением понимаем разбиение с пустым параметром fork и кортежем splitting из одного элемента т.е. (, (1))
\end{definition}

Далее введём некоторый набор операций, доступный над разбиениями.
\begin{enumerate}
\item[-] Произведение двух разбиений задаётся рекурсивной функцией mult от двух аргументов, возвращающей  новое разбиение. ~\cref{tab:mult}
\item[-] Сложение двух разбиений задаётся рекурсивной функцией sum от двух аргументов, возвращающей  новое разбиение.~\cref{tab:sum}
\item[-] Проверка на конкуренцию задаётся рекурсивной функцией concurrent от двух аргументов, возвращающей  True в случае выявления конкуренции и False в противном случае, . ~\cref{tab:conc}
\end{enumerate}

В каких случаях используются данные операции над разбиениями будет определено в дальнейшем. А пока приведём несколько примеров их применения:\\

Умножение двух разбиений:
\begin{equation}
	(, (1)) \times (b1, (0,1)) = (, (b1, (1,0)))
	\nonumber
\end{equation}
\begin{equation}
	(, (b1, (1,0, 1))) \times (b2, (0,1)) = (, (b1, ((b2, (0,1)),0, (b2, (0,1)))))
	\nonumber
\end{equation}

Сложение двух разбиений:
\begin{equation}
	(, (b1, (1,0))) + (, (b1, (0,1))) = (, (b1, (1,1))) 
	\nonumber
\end{equation}

При сложении двух разбиений так же применяется рекурсивное правило \textit{упрощения}, которое определяется как:\\
 Пусть дано разбиение WS = (fork, split), у которого кортеж split состоит из одних единиц и WS не является нулевым разбиением, тогда $WS \equiv 1$:
\begin{equation}
	(, (b1, (1,0))) + (, (b1, (0,1))) = (, (b1, (1,1))) \equiv (, (1))
	\nonumber
\end{equation}

Проверка двух разбиений на конкуренцию:

\begin{equation}
	(, (b1, (1,0))) \perp (, (b1, (0,1))) = True
	\nonumber
\end{equation}

\begin{equation}
	(, (1)) \perp (, (b1, (0,1))) = False 
	\nonumber
\end{equation}



\begin{table}
    \begin{tabular}{|l|>{\centering}m{8cm} |l|l|}
    \hline
    ~   & WS1                                                                              & 1       & 0       \\ \hline
    WS2 & (WS1.fork,\\
    ([(WS1.split[i] $\times$ WS2) for i in [0,...,n]]))\\
      & WS2  & 0    \\ \hline
    \end{tabular}
\caption{Таблица функции умножения двух разбиений}\label{tab:mult}
\end{table}



\begin{table}
    \begin{tabular}{|l|>{\centering}m{8cm} |l|l|}
    \hline
    ~   & WS1                                                                              & 1       & 0       \\ \hline
    WS2 & if WS1.fork == WS2.fork \\
    then (WS1.fork, ([(WS1.split[i] + WS2.split[i]) for i in [0,...,n]]))\\
     else throw() & throw() & WS2     \\ \hline
    1   & throw()                                                                          & throw() & 1       \\ \hline
    0   & WS1                                                                              & 1       & throw() \\ \hline
    \end{tabular}
\caption{Таблица функции сложения двух разбиений}\label{tab:sum}
\end{table}




Сравнение на конкуренцию двух разбиений производится следующим образом:
\begin{table}[here]
    \begin{tabular}{|l|>{\centering}m{8cm} |l|l|}
    \hline
    ~   & WS1                                                                                   & 1     & 0     \\ \hline
    WS2 & if WS1.fork == WS2.fork \\
    then all([(WS1.split[i] $\perp$ WS2.split[i]) for i in [0,...,n]])\\
     else False & False & True  \\ \hline
    1   & False                                                                                 & False & True  \\ \hline
    0   & True                                                                                  & True  & False \\ \hline
    \end{tabular}
\caption{Таблица функции проверки двух разбиений на конкуренцию}\label{tab:conc}
\end{table}
\\

Так же дадим определение волны, которое будет представлять некоторую  связь с сигналом на выходящем порту и содержать информацию о распространяемом потоке внутри workflow.
\begin{definition}{Определение: Волна(Wave)}
Волной внутри workflow, заданного графом связей WFG  = (A,D), будем называть связку вида (d, WS) , где $d \in D$ - ребро графа связей, WS - некоторое разбиение. 
\end{definition}




Для моделирования работы workflow введём такое понятие как состояние workflow. Состояние характеризуется тем моментами, между работой блоков.
Работу каждого блока мы  будем считать атомарной операцией.

\begin{definition}{Определение: состояние workflow (Workflow State)}
   Для worklow с заданным графом связей WFG  = (A,D), состояние определяется как набор \textit{(BlockStates, WaveFront, BlockHistory )}
   \begin{enumerate}
   \item[-] BlocksStates - отображение  $ BS : a \rightarrow s_{a}, a \in A, s_{a} \in states(a)$ , сопоставляющая каждому блоку в составе workflow его текущее состояние. 
   \item[-] WaveFront - набор волн.
   \item[-] BlockHistory - отображение $ H : a \times p_{in}  \rightarrow splits, a \in A, s_{a} \in states(a), p_{in} \in in(a)$, сопоставляющая каждому блоку и его входного порта $p_{in}$ набор разбиений потока. 
   \end{enumerate}
\end{definition}

При этом идентификатором уникальности любого состояния workflow  WFS = (bs, front, hist)
будет только двойка (bs, edges), где edges - набор рёбер $ \lbrace d :  (d, ws) \in front \rbrace$.



\begin{definition}{Определение: начальное состояние workflow (Initial Workflow State)}
	Начальным состоянием workflow будем называть то состояние textit{($bs_{init}, front_{init}, hist_{init} $)}, в котором каждый блок находится в начальном состоянии, в соответствии с его конечным автоматом, и набор волн $front_{init}$ , соответствующий испущенным сигналам из выходных портов блока \textit{Source}. $hist_{init}$ считаем пустым.
\end{definition}


 
{Описание алгоритма нахождения новых состояний workflow за 1 шаг} 

Введённая модель такова, что для каждого блока известна его FSM, которая задаёт 

Пусть дано задано workflow WFS  = (bs, front, hist)
\begin{enumerate}
\item По WaveFront определяем на какие его входные порты поступили сигналы и по его состоянию из BlockStates определяем набор вариантов работы этого блока. Прямое произведение вариантов работы всех блоков на для данного состояния, даст нам все созможные варианты работы workflow за один шаг.

\item Для каждого элемента этого произведения, вычислим новое возмоное состояние workflow: \\

для каждого блока последовательно выполняиется проверка и преобразование соответствующего состояния.

Параметр разбиения каждой волны  проверяем на конкурентность с разбиениями прошедшими, через соответствующий порт блока а.
В случае, если какая либо пара разбиений окажется конкурентной, означает, что обнаружено потенциальное состояние гонки , что мы считаем ошибкой в композиции workflow. При этом мы знаем детализированную информацию о месте возникновения состояния гонки, и о всех пройденных шагах.

Если ошибок не обнаружено, то рассчитаем промежуточное значение разбиения потока:\\
$ws_{sum} = \sum_{w \in waves_{in}} w.split)$ 

Теперь считаем значения выходных волн:\\
$waves_{out} = \lbrace (edges_{out}[i], ws_{sum} \times (a, 1_{i, n_{out}}):  i \in [1, n_{out}] \rbrace$.  
\end{enumerate}





\subsection{Построение сети Петри на основе полученного графа состояний}



\section{Постановка задачи оптимального запуска workflow в распределённой среде}






\end{document}