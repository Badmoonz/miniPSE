\documentclass[a4paper,14pt]{article}
\usepackage{amsmath,amsfonts,amssymb,amsthm,epsfig,epstopdf,titling,url,array}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
%\usepackage[T2A]{fontenc}
\usepackage{amsmath,amssymb,amsthm,amscd,amsfonts,graphicx}
\usepackage[14pt]{extsizes}

\newcommand{\workflow}{\textit{workflow}}
\newenvironment{definition}[1]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\title{Дипломная работа}

\begin{document}
\maketitle
\textwidth 15.5cm
\topmargin -1cm
\parindent 1cm
\textheight 24cm
\parskip 1.5mm



\section{Введение}

Today’s scientific experiments typically in-
volve running and refining a series of intertwined computa-
tional analysis and visualization tasks on large amounts of
data. The complexity of these so-called analysis pipelines
resulting in high costs for development and maintenance,
the need for sharing knowledge encoded in these pipelines
as well as hardware to execute them, and the need for re


За последних два десятилетия в научном сообществе компьютерное моделирование, названное eSience, стало незаменимой частью исследовательского процесса наравне с традиционными инструментами, такими как эмперические, основанное на  экспериментальных наблюдениях, теоретическое моделирование. Компьютерное моделирование включает в себя 

\subsection{Мотивация}
Мотивация
\section{Базовые понятия и определения}
\section{Формальное описание модели актор-ориентированных исследовательских workflow}
В данном разделе будут введены базовые понятия, используемые в данной работе, в том числе,
понятия атомарного блока, составного блока, потока данных, автомата Мили соответствующего блоку и так далее.
\subsection{Графы актор-ориентированные иерархических workflow\\(Actor-Oriented Hierarchical Workflow Graphs)}

\begin{definition}{Граф связей workflow}
 Граф связей workflow $W =(A, D)$ состоит из набора акторов $A$, представляющих  задачи и набора связей , соединяющих акторы через порты. Акторы по своей сути явзяются пассивными, т.е. на набор входных данных выдают 
 Акторы передают друг другу токены данных через сообщающиеся порты.
\end{definition}

\begin{definition}{Порты}
Для каждого актор $a \in A$ существует собственный набор портов $port(a)$, таких что каждый порт $p \in ports(a)$ является либо входящим , либо выходящим для этого актора, т.е. $ports(a) = in(a) \cup out(a)$
%input/output signature ΣA of A, denoted A :: in(A) −→ out(A).3

\end{definition}

\begin{definition}{Связи}
Пусть для workflow $in(W) = {\bigcup_{a \in A} in(a)}$ будет набор всех входных портов, $out(W) = {\bigcup_{a \in A} out(a)}$ набором выходных портов соответственно. Тогда связь $d \in D$ будет направленным ребром $d = \langle o,i \rangle$
\end{definition}

\begin{definition}{Обобщение и дробление \workflow}
Обобдение и дробление workflow являются ключевыми примитивами в составлении workflow. Для обобщения \workflow $W$ следовало бы представить его в виде \textit{составного актора} $a_{W}$, иными словами \textit{"свернуть"}. И наоборот, при дроблении, \textit{"раскрывая"} актор, получить 
\end{definition}


\subsection{Описанаие актора}
Базовой логической единицей потока данных является атомарный актор. Т.е. тот, который задаётся только Недетерменированным конечным автоматом(FSM). 
 
Состояние любой системы или подсистемы в любой определённый момент времени характеризует, как система(продсистема) будет реагировать на входные данные.
Формально, под состоянием мы будем подразумевать всю накопленную системой информацию, которая влияет на поведение системы в текущий момент и в последующие.

Для примера рассмотрим простой актор типа Counter, который считает количество собственных запусков. У него разумеется есть состояние, и его реакция на входные данные из порта trigger зависит от того, сколько раз он уже сработал. Для подсчёта и зранения числа запусков он использует локальную переменную. И эту локальную переменную будем называть \textbf{переменной состояния}.
\\ 
В этом случае количество возможных состояний определяется типом счётчика. Если, к примеру, это int , то возможно только $2^{32}$ состояний, если double, то $2^{64}$. Если же тип счётчика  String, то число состояний бесконечно. Но не смотря на то что число состояний может быть очень болшим, логика переходов между ними достаточно проста. 

\begin{definition}{Finite State Machines}
Автоматом называется система , выходы которой зависят не только от поступивших входов, то и от текущего состояния системы. Состояние системы - объедие всей информации о предшествующих входах, необходимое системе для выполнения шага. Состояние системы может быть обозначено переменной состояния $s \in \Sigma$, где $\Sigma$  - это набор всех возможных состояний системы. Конечным автоматом называется автомат, для которого число состояний $\Sigma$ конечно.
\\
Внутренняя логика блока представляется моделью недетерминированного конечного автомата ( Finite State Machine, FSM)
Определение: конечным автоматом называется набор $ M = (\Sigma, I,\Lambda, T, s_{0})$ , где
\begin{enumerate}
\item[-] S -набор конечных состояния,
\item[-] $I$ – набор входных портов актора,
\item[-] $O$ - набор возможных выходных портов актора
\item[-] $s_{0} \in \Sigma$ - начальное состояние,
\item[-] $T: S \times 2^{I} \rightarrow  2^{S \times 2^{O}}$ отображениеб сопоставляющее каждому состоянию с наборов входных портов набор состояний с соответствующим набором выходных портов
\end{enumerate}


Как уже было определено выше, у актора имеется \textbf{начальное состояние} $s$, т.е. то в котором модель находится перед запуском. Тах же могут быть и \textbf{конечные сотояния}. Визуально состояния соединены переходами, рядом с которыми указано, что проиходит при срабатывании работе.


Классическая теория конечных автоматов  (Hopcroft and Ullman, 1979) различает два вида автоматов: \textbf{Автомат Мили} и \textbf{Автомат Мура}. В Автомате Мили , от входных значений, в отличии от Автомата Мура, выходное значение сигнала в котором зависит лишь от текущего состояния данного автомата.


\end{definition}




\section{The Need for Composing Models of Computation in E-science}

\section{Workflows and Hierarchy}
Описание понятия  	акторa(actor,atomic actor.
,composite actor (a.k.a. sub-workflow))
\section{(Модели управления потоком)Models of Computation}
\subsection*{Process Networks (PN)}
\subsection{Использование PN}
\begin{enumerate}
\item[•] Тупики
\item[•] 
\end{enumerate}
Более подробно модель описывается  через Kahn networks.
Каждый актор запускается в отдельно треде(thread)(или вычислительном узле), и все акторы запускаются в конкурирующем режиме. 


\section*{SDF}
\subsection{Задачи}
\subsection{Использование SDF}
\begin{enumerate}
\item[] Deadlocks
\item[•] Consistency of data rates
\item[•] The value of the iterations parameter
\item[•] The granularity of execution
 Более подробно в секции 3.3.
\end{enumerate}
\subsection{Тупики(Deadlocks)}
\subsection{Consistency of data rates}
Все акторы внутри \textit{однородного(homogeneous)} SDF принимают только по одному токену из каждого входного порта и выписывают по 1 токену в наждый выходно порт. В кадом цикле должить быть "сдерживающий" актор,  так что dataflow-граф будет ациклическим , если убрать все "сдерживающие" акторы. Схему запуска можно определить статически, например, через топологическая сортировка графа.
%\subsubsection{Количество итераций}
\subsection{Свойства SDF}
\par SDF не связан с временными событяиями. Для всех акторов,входящих в SDF,  поглощение токенов из входных портов, выполнение вычисленых операций и отправление токенов в выходные порты явсляется атомарной операцией. Запуск композитного актора соответствует одной итерации содержащейся в нём модели по предварительно вычисленной схеме(schedule). При это схема выполнения рассчитывается так, чтобы , и при бесконечном числе итераций в модели не возникали тупики и накопление токенов. 
\subsubsection{Вычисление схем запуска}
Вложенные друг в друга SDF модели , можно уплощать(flasttern),
Запуск последовательный, преимущзественно на одном узле.

\section*{FSM}
Конечные автоматы (Finite State Machines) 
\section*{DDF}


В этой модели управления вместо того, чтобы выдавать каждому актору отдельный тред, система управления запускает отдельный актор, когда необходимые удовлетворены его зависимости на входе.  Dataflow делятся на два типа, dynamic dataflow (DDF) и synchronous dataflow (SDF). В случае DDF, система управления динамически определяет  какой актор необходимо запустить в следующим, и следовательно составляет схему запуска(firing schedule) динамически во время работу. В случае SDF, сиситема управления 
\begin{enumerate}
\item[•] Сети Петри
\item[•] Анализ Сетей Петри
\item[•] Граф Карпа и Миллера 
\item[•] Marked Graphs
\item[•] Однородные dataflow
\item[•] Обобщённые dataflow
\item[•] Модели Kaна (Khan) для параллельных вычислений
\end{enumerate}

9.0  Специальная лексика
 Dataflow - поток данных 


10.0 Используема литература

\section{СЕТИ}
\subsection{Сети Петри}
Сети Петри широко используются для моделирования и исcледования динамических дискретных систем. 
И прежде чем рассмотреть рассмотреть частные случаи использования Сетей Петри, приведём описание их каноничной формы, согласно определению Петерсона [Pet81].
\par Сеть Петри представляет собой двудольный ориентированный граф, состоящий из вершин двух типов — \textit{позиций} и \textit{переходов}, соединённых между собой дугами. Вершины одного типа не могут быть соединены непосредственно. В позициях могут размещаться метки (маркеры), способные перемещаться по сети.\\
Простой сетью Петри наызвается набор $N = (S,T,F)$ , где
\begin{enumerate}
\item $S = \lbrace s_{1},\ldots,s_{n} \rbrace$ - множество \textit{позиций}
\item $T = \lbrace t_{1},\ldots,t_{r} \rbrace$ - множество \textit{переходов} таких, что $S \bigcap T = \varnothing$.
\item $F \subseteq \mu S \times T \times \mu S$ - отношение \textit{инцидентности} такое, что 
\begin{enumerate}
\item[•] $\forall \langle  Q_{1}^{'}, t_{1}, Q_{1}^{''} \rangle , \langle Q_{2}^{'}, t_{1}, Q_{2}^{''}\rangle \in F : \langle Q_{1}^{'}, t_{1}, Q_{1}^{''} \rangle \neq \langle Q_{2}^{''}, t_{2}, Q_{2}^{'}\rangle \Rightarrow t_{1} \neq t_{2};$
\item[•] $\lbrace t | \langle  Q_{1}^{'}, t_{1}, Q_{1}^{''} \rangle \in F \rbrace = T$
\end{enumerate}
\end{enumerate} 
Условия в пункте 3 говорят , что для каждого перехода $t \in T$ существует единственный элемент $\langle Q^{'}, t, Q^{''} \rangle$, задающий для него входное мультимножество $Q^{'}$ и  выходное мультимножество $Q^{''}$. Дадим определение входному и выходному мультимножеству.

\textbf{Определение:}  \textit{Входное и выходное мультимножества мест и переходов}
\par Пусть задана сеть $N = (S,T,F)$.
\begin{enumerate}
\item Если для некоторого перехода t имеем $\langle Q^{'}, t, Q^{''} \rangle \in F$ , то будем обозначать \\$\bullet t = Q^{'} = \langle (s,n)|(t,n) \in s \bullet \rangle , t  \bullet = Q^{''} = \langle(s,n) | (t ,n) \in \bullet s \rangle$
\item  И соответственно\\$\bullet s = \langle (t,n)|(s,n) \in t \bullet \rangle , s \bullet = \langle(t,n) | (s ,n) \in \bullet t \rangle$
\end{enumerate}

Будем говорить, что $\bullet t$ - входные , а $t \bullet$ - выходные позиции для перехода t. Таким образом, соласно определению, справедливо:\\ $\forall t \in T : \langle \bullet t, t, t \bullet \rangle \in F $.\\ Позиция s называтся инцидентной переходу t , если $s \in \bullet t$ или $s \in t \bullet$.


Сети Петри имеют удобную графическую форму представления в виде графа, в котором места изображаются кружками, а переходы прямоугольниками. Места и переходы, причем место s соединяется с переходом t если $(s,n) \in \bullet t$ и t соеднияется с s если $(s,n) \in t \bullet$  для некоторого натурального числа $n \in N$ . Здесь число n называется кратностью дуги, которое графически изображается рядом с дугой. Дуги, имеющие единичную кратность, будут обозначаться без приписывания единицы. 

Само по себе понятие сети имеет статическую природу. Для задания динамических характеристик используется понятие маркировки сети $M \i \mu S$, т.е. функции $M : S \longrightarrow N_{0}$, сопоставляющей каждому месту целое число. Графически маркировка изображается в виде точек, называемых метками (tokens), и располагающихся в кружках, соответствующих местам сети. Отсутствие меток в некотором месте говорит о нулевой маркировке этого места.

\textbf{Определение:}  \textit{Маркированная сеть Петри}
Маркированной сетью Петри называется набо $\Sigma = (S,T,F M_{0})$, где
\begin{enumerate}
\item (S,T,F) - сеть;
\item $M_{0} \in  \mu S$ - наяальная маркировка.
\end{enumerate}

Работа мариковочной сети Петри управляется наличием или отсутствием маркировочных токенов. Сеть Петри срабатывает  переход t, в процессе которого c каждой  мультипликативного входа $(s, n) \in I(t)$ снимается по n токенов с каждого, где n - соответствующая кратность дуги и каждому мультипликативного выходу $(s, m) \in O(t)$ прибавляется m токенов.
Для любого положения количество токенов не может быть отрицательным, поэтому переъод не может сработать, если количство токенов на входах меньше требуемого количества токенов на выходе. 

\textbf{Опеределение: } \textit{Правило срабатывания переходов}
Пусть $\Sigma = (S,T,F M_{0})$ маркировочная сеть.
\begin{enumerate}
\item Переход $t \in T$ считается возбуждённым при маркировке $M \in \mu S$ если $M \geq I(t)$;
\item переход t, возбуждённый при маркировке M,  может сработать, приведя к новой маркировке$M^{'}$,  которая вычисляется по правилу: $M^{'} = M - I(t) + O(t)$. Срабатывание перехода обозначается 
\end{enumerate}


\textbf{ПРИМЕР}

\subsection{Анализ сетей Петри}
Сети петри могут быть использованя для моделирования конкурирующих систем. К примеру, сеть процессов с общей памятью. 

\par Композициональный подход к построению сетей Петри предполагает возможность построения более сложных сетей из менее сложных составляющих. Для этого вводятся точки доступа, которые позволяют объединять простые сети путём синхронизации событий и состояний (переходов и мест).
\par Обычно в сетях Петри считается, что если при одной и той же маркировке возбуждено несколько переходов, то может сработать любой, но только один из них. Это ограничение не является принципиальным и может быть снято.
При применении сетей Петри для целей управления позициям сопос­
тавляются операции (действия), а переходам — условия, при выполнении
которых возбужденные переходы срабатывают, активизируя соответству­ ющие операции. При этом попадание меток в позицию ассоциируется с началом операции, а удаление метки — с ее окончанием. При использовании такого предположения считают, что любая операция не может быть повторно начата до ее завершения. Для описания таких процессов могут применяться только безопасные сети петри, т. е. такие сети, в которых при любой начальной маркировке $\mu$ невозможно ни через какую последовательность выполненных переходов получить такую маркировку $\mu^{'}$ с количеством токенов в положении больше единицы.
\par Возможно сделать сеть Петри быть безопасной добавляя дуги, обеспечивая 
Безопасность 







\begin{thebibliography}{10}
\bibitem{GG}[GG] Gray L., Griffeath D. The ergodic theory of traffic jams // J. Stat. 
\end{thebibliography}{10}

\end{document}
