\documentclass[10pt,a4paper,onecolumn]{report}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}       %поддержка кириллицы
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Maxim Borisyak}
\title{Дипломная речь}
\setlength{\textwidth}{165mm} \setlength{\textheight}{245mm}
\hoffset=-15mm \voffset=-35mm

\begin{document}

\section{Введение}

  Моя работа посвящена построению, анализу и оптимизации динамического потока данных в однородной распределенной среде.
  В этой работе были поставлены следующие цели:
  \begin{itemize}
    \item создание формальной модели потоков данных,
    \item анализ неопределенностей в схемах потоков данных,
    \item оценка ресурсов необходимых для запуска потока данных в однородных распределенных средах.
  \end{itemize}
  
  Вначале рассмотрим определение понятия потоков данных.
  Поток данных является концепцией представления вычислительных процессов.
  Основной особенностью концепции потоков данных является представление вычислительного процесса в виде
  набора независимых функций-исполнителей, которых мы будем называть блоками, и связей, представляющих каналы передачи данных.
  Также многие системы построения и запуска потоков данных поддреживают возможность создания многоуровневых или иерархичных потоков данных и
  задание стратегии выполнения.
  
  Рассмотрим теперь задачи, для решения которых пременяются потоки данных.
  Особено часто потоки данных применяются для решения научных и инжинерных задач, в которых требуется обработка больших объемов данных и соответственно
  большие вычислительные мощности, которые можно достичь только с помощью распределенных сред вычислений. Так как создание программ для вычислений в таких среда
  сопряжено со многими техническими аспектам, для потоков данных также предъявляется требование к изоляции от конкретных особенностей вычислительной среды.
  Также важна отказоустойчивость вычислительного процесса.
  
  Главными приемуществами потоков данных является изолированность описание вычислительного процесса от технических деталей запуска.
  Также распространненость потоков данных объясняется возможностью удобного визуального представления и соответсвенно простотой создания алгоритмов,
  не требующей специальных знаний в области информатики.
  
  Рассмотрим теперь способы представления потоков данных. Среди часто используемых можно выделить такие как:
  \begin{itemize}
    \item декларативные или скриптовые языки программирования,
    \item графы, вершинами которых являются блоки, а ребра представляют каналы связи,
    \item сети Петри,
    \item сети процессов Кана, применяющиеся для потоковой обработки.
  \end{itemize}
  
  Перейдем теперь непосредственно к описанию модели, рассматриваемой в этой работе.
  В нашей модели используется представление в виде графа. Весь поток данных представляется в виде четверки:
  \begin{itemize}
    \item $B$ --- множество блоков,
    \item множество $E$ задает связи или каналы передачи данных,
    \item множества $I$ и $O$ описывают собственные входные и выходные порты потока данных подобно блоку.
  \end{itemize}
  На слайде Вы можете видеть графическое представление иерархического потока данных.
  Внутри синей рамки показана структура подпотока данных, который на самом высоком уровне представляется в виде блока с одним
  входом и выходом.
  
  Преобразование данных в концепции потоков данных осуществляют блоки.
  В нашей модели блок определяется следующим образом.
  \begin{itemize}
    \item наборы $I$ и $O$ входных и выходных портов блока,
    \item $FA$ --- конечный автомат Мили.
  \end{itemize}
  
  Основной особенностью этой модели является замена детерминированного алгоритма обработки данных на соответствующий конечный автомат Мили,
  который показывает качественное поведение алгоритма. Замена нужна только для статического анализа. Иными словами автомат Мили
  описывает поведение алгоритма в отсутствии предположений на входящие данные.
  Состояние автомата Мили показывают характерные классы внутренних состояний алгоритма обработки, переходы определяют
  качественные показатели работы блоков --- наборы поглащенных и успущенных данный.
  Входной и выходной алфавиты соответственно множество подмножеств входных и выходных портов.
  
  На слайде Вы можете видеть графическую нотацию блоков автомата Мили.
  На первом слайде нарисован блок отвечающего за цикл и его автомат Мили.
  Поясним принцип автомата Мили этого блока.
  Состояние initial соответствует отсутствию внутреннего состояния алгоритма блока.
  Состояние non\_trivial соответствует промежуточному состоянию --- блок находится в процессе итерации.
  Переход из initial в initial отвечает за пустой список для преобразования.
  Переход из начального состояния в состояние итерации соответствует началу работы, то есть первой итерации.
  При этом блок поглощает сам список и выдает его первый элемент.
  Далее в состоянии итерации блок ожидает преобразованное значение и соответственно может выйти из цикла, излучив результат,
  либо продолжить итерацию в зависимости от длины остаточного списка.
  
  Перейдем теперь к работе потока данных.
  Каждый блок в процессе работы может находиться в одном из трех состояний.
  На рисунке схематично изображен граф переходов между состояниями блока.
  \begin{itemize}
    \item свободен --- означает, что блоку не хватает данных для начала работы;
    \item работает,
    \item заблокирован.
  \end{itemize}
  Состояние заблокирован возникает из-за дополнительного упрощения, которое вводится в модели --- каждый канал передачи данных,
  представляется в виде очереди с длиной не более 1. Поэтому блок, который завершившил свою работу, но не может излучить результат,
  переходит в состояние заблокирован.
  
  Теперь рассмотрим алгоритм запуска всего потока данных.
  Алгоритм в словестном виде представлен на слайде.
  В начале работы система управления опрашивает каждый блок, чтобы узнать необходимые наборы данных для запуска.
  Далее данные передаются необходимым блокам и осуществляется разрешение состояние блокировки. После разрешения состояний блокировки,
  система управления ожидает первый завершившийся блок и повторяет алгоритм с начала, до выполнения условий на завершение потока.
  
  Описанная выше модель является довльно гибкой и удобной для построения потоков данных, однако она допускает неопределенности в своей работе.
  Рассмотрим их. Первый тип неопределенностей связан с заменой алгоритмов блока на автомат Мили и является неизбежным следствием незнания входных данных во время статического
  анализа.
  Однако существует второй тип неопределенностей, который связан уже с самими принципами работы данных. Среди этих неопределенностей следует особо подчеркнуть
  состояния гонок.
  Неопределенности первого и второго типа будем называть неопределенностями первого и второго рода.
  
  Наличие неопределенностей второго рода говорит о необходимости исправления схемы потока данных, так как результат выполнения потока становится зависим
  от сторонних факторов, как, например, время работы блоков или способ разрешения неопределенностей.
  Корректным потоком данных будем называть поток, схема которого не допускает неопределенностей второго рода.
  
  Далее мы будем рассматривать анализ корректные потоки данных
  
  Для поянения работы алгоритмов нам потребуются определения некоторые определения.
  Траекторией потока данных мы назовем последовательность состояний потока данных во времени.
  Каждой траектории соответствует граф причинности, который мы будем в дальнейшем активно использовать.
  Граф причинности представляется в виде графа, где вершинами являются переходы совершенные блоками, а ребра
  соответствуют <<причинам>> --- между вершинами A и B есть ребро, если блок B использовал данные испущенные блоком A.
  
  Граф причинности описывает поведение потока данных в конкретном случае разрешения неопределенностей.
  Именно на графах причинности основывается дальнейший анализ, поэтому возникает задача описания всех возможных графов причинности.
  
  Множество все траекторий разбивается на классы эквивалентности соответствующие графам причинности, причем
  в случае корректного потока данных в каждом классе содержатся траектории со всеми возможными случаями времен работы блоков.
  
  На этом факте предложенный основывается волновой алгоритм.
  Рассмотрим варинт волнового алгоритма для случая ацикличного потока данных.
  Алгоритм представляет из себя рекурсивную функцию, которая по схеме потока данных, строит множество всех возможных графов причинности.
  Сам алгоритм в словестной форме представлен на слайде.
  Идея алгоритма заключается в моделировании работы потока данных и дополнении неполного графа причинности с учетом неопределенностей первого рода.
  
  Также был создан волновой алгоритм для общего случая потоков данных.
  Он представляет из себя модификацию простого волнового алгоритма.
  Однако для разрешения циклических зависимостей алгоритм строит "внутренний" автомат работы потока данных.
  Множество графов причинности представляет из себя аналог регулярного языка из теории синтаксического анализа, а "внутренний" автомат является аналогом
  конечного автомата для этого языка.
  Для наших целей нет смысла рассматривать более одной итерации цикла.
  
  Сделаем небольшое отступление от основной темы.
  В начале работы предпринимались попытки ввести некие вероятностные модели работы блоков. Однако простые верятностные модели дают отрицательный результат.
  Для демонстрации этого достаточно рассмотреть пример приведенный на слайде.
  На первом рисунке изображен часто используемый поток данных, представляющий из себя простой цикл. Уже знакомый автомат блока цикла представлен на втором рисунке.
  Ясно, что общее время работы этого потока данных зависит от количества итераций. Если ввести вероятности на переходах автомата Мили блока цикла,
  то не сложно получить нижнюю формулу для мат. ожидания длины цикла. Как видно мат. ожидание длины цикла можно сделать любым, подбирая соответствующие вероятности.
  Однако на практике характерных длин циклов в зависимости от задачи цикла может достигать нескольких порядком, что говорит от неприменимости простых вероятностных моделей
  для довольно широкого класса потоков.
  
  Поэтому в этой работе представлен метод схожий по принципам с минимаксным методом.
  Теперь рассмотрим задачу анализа графов причинности.
  Как уже говорилось, граф причинности является описанием поведения потока данных.
  Для того, чтобы получить оценки на количество вычислителей, необходимых для успешного запуска потока данных, достаточно вычислить следующие величины.
  Вначале нам понадобятся два определения.
  Срезом графа причинности мы назовен множество независимых задач, то есть которые могут выполняться независимо или параллельно.
  Эволюция графа причинности --- это набор связанных срезов. Эволюция показывает работу потока данных в терминах, какие задачи выполняются после каких,
  какие задачи выполняются одновременно.
  Теперь введем следующие оценки $N_min$ и $N_max$. Каждой эволюции сопоставим максимальное количество задач, которое выполняется одновременно или мощность максимального среза.
  Оценки $N_min$ и $N_max$ --- это минимум и максимум по всем эволюциям этого максимального количества задач.
  Другими словами, оценки $N_min$ и $N_max$ имеют следующий смысл. Если взять количество вычислителей ниже, чем $N_min$, то заведомо возникнет конкуренция.
  Брать количество вычислителей выше, чем $N_max$ не имеет смысла, так как некоторые вычислители будут заведомо простаивать.
  
  Вычисление оценок производилось алгоритмом HEFT, который изначально предназначен для обработки графов задач.
  Данные оценки приведены для одного графа причинности. Для получения оценок для всего потока данных, можно взять минимуму и максимумы по графам причинности этих двух оценок.
  
  В большинстве прикладных потоков данных оценки дают малый разброс, однако в ряде специальных случаев дают разброс может быть существенным.
  Для решения этой проблемы предлагается метод динамического уточнения оценок.
  Этот метод может быть полезен для эфективного использования мощностей кластеров и суперкомпьютеров. В процессе работы поток данных в зависимости от результата выполнения,
  имеет возможность уточнять оценки необходимых ресурсов и возвращать в процессе работы зарезервированные ресурсы.
  В процессе работы волновой алгоритм достраивает граф причинности инкрементально, неявно создавая префиксное деревой графов причнности.
  Идея метода динамического уточнения оценок заключается в следующем. Для каждой вершины этого дерева вычисляются оценки для остаточных графов причнности.
  Далее это дерево может использовать система управления потоками данных --- в процессе работы осуществляется сужение возможных для реализации графов причноости,
  попутно уточняя оценки для необходимых ресурсов.
  
  Для пояснения работы можно рассмотреть пример.
  На слайде изображена схема потока данных. В этом потоке не тривиальными автоматами Мили обладают только блоки условных переходов If1 и If2.
  Всего в этом потоке возможны три графа причинности на каждую ветку условных переходов.
  Случай рассматривается в преположении, что на практике реализуется вторая ветка условных переходов.
  Сами графы причиности изображены на слайде.
  На графике показано изменения оценок вычисляемое по предложенному методу.
  
  Все рассмотренные алгоритмы и соответственно оценки верны только для корректных потоков данных. Они допускают расширение на случай некорректных потоков данных,
  однако, как уже было сказано, такие потоки нуждаются скорее в исправлении, нежели анализе.
  Рассмотрим теперь задачу проверки потока данных на корректность. В волновых алгоритмах уже были неявно рассотренны
  случаи некорректного завершения и вариантов поглощения данных, поэтому нас будет интересовать задача обнаружения состояний гонок.
  Существует два типа состояний гонок: изменение набора входных портов при поглощении и наличие вариантов поглощения из одного порта.
  Для обнаружения этих типов состояний гонок была рассмотренна модификация волнового алгоритма, заключающаяся в процедуре проверки при каждом поглощении данных.
  Эта процедура осуществляет проверку на наличие неопределенностей по истории поглощений из портов блока. Также вводится история волны, которая реализует проверку на корреляцию волн ---
  волны считаются коррелирующими, если одна является потомком другой. Некоррелирующие волны считаются конкурирующими и именно они могут изменять порядок поглощения
  при изменении времен работы блоков.
  
  Отдельно стоит рассмотреть класс блоков, автоматы Мили которых являются детерминированными по входу, или, другими словами, для которых в каждом состонии существуют переходы только
  по одному набору входных портов. Так этот класс автоматов Мили автоматически исключает состояние гонки, связанное с различными вариантами поглощения.
  Любой алгоритм блока можно модифицировать таким образом, что его автомат Мили станет детерминированным по входу. Однако часто это пораждает неудобства при построении потока данных.
  Для примера можно рассмотреть модификацию блока аппроксиматора. Обычно процесс аппроксимация преставляется двумя блоками: одни строит модель, второй получает на вход модель
  и вычисляет аппроксимированные значения в подаваемых точках. На слайде изображено два варианта автоматов блока. Недетерминированный вариант алгоритма в состоянии with\_model
  мог принимать как новую точку, так и новую модель. Для преведения к детерминированному виду потребовалось ввести дополнительный порт action, который определяет следующее действие:
  ожидание новой точки, либо новой модели. Из рисунка видно, что автомат заметно усложнился, а новый принцип его работы вносит дополнительные трудности в построении потока данных.
  Заметим, что подобным образом можно преобразовать любой алгоритм блока к детерминированному виду.
  
  На этом моя дипломная работа завершается.
  В результате проделанной работы была построенна модель потоков данных, основной особенностью которой была замена алгоритма блока на автомат Мили,
  качественно описывающий поведение блока.
  Далее модель была исследована, были выявлены все случаи неопределенностей --- одни являются следствием упрощения описания блока, другие возникают из-за ошибок
  построения схемы потока данных.
  Далее были предложены алгоритмы нахождения графов причинности, каждый из которых полностью описывают поведение потока в одном случае. По этим
  графам были найдены оценки для необходимого количества вычислителей для наилучшего запуска потока данных в распределенной среде.
  Также был предложен метод динамической корректировки этих оценок в процессе работы потока данных.
  Также была рассмотрена задача проверки потока данных на корректность.
  
  В процессе работы были выявлены следующие возможные дальнейшие исследования:
  \begin{itemize}
    \item Введение более сложной системы оценки времен работы и вероятностей переходов блоков, которая возможно даст положительные результаты.
          Однин из возможных вариантов --- введение характеристических чисел для данных и правила их преобразования блоками.
    \item В процессе работы рассматривалась идея оценки наилучших параметров запуска путем автоматической кластеризации блоков для создания многоуровневой иерархии.
          Один из возможных вариантов --- создание шаблонов составных блоков и поиск по ним.
    \item Также возможны модификации самой модели потоков данных.
    \item Возможно расширение алгоритмов для анализа поведения потоков данных в гетерогенных средах.
    \item В этой работе частично рассматривалась идея ограничения классов автоматов для конкретного класса. Также возможно ограничение на наборы используемых атомарных блоков,
          с целью получения потоков, с определенными свойствами.
  \end{itemize}
  
  The End.
\end{document}