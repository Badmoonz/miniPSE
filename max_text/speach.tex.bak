\documentclass[10pt,a4paper,onecolumn]{report}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}       %поддержка кириллицы
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Maxim Borisyak}
\title{Дипломная речь}

\begin{document}

  Моя работа посвящена построению, анализу и оптимизации динамического потока данных в однородной распределенной среде.
  В этой работе были поставленны следующие цели:
  \begin{itemize}
    \item cоздание формальной модели потоков данных,
    \item aнализ неопределенностей в схемах потоков данных,
    \item оценка ресурсов необходимых для запуска потока данных в распределенных средах.
  \end{itemize}
  
  Вначале рассмотрим понятия потоков данных.
  Поток данных является концепцией представления вычеслительных процессов.
  Среди характерных особенностей потоков данных можно выделить представление в виде наборов независимых вычислителей (акторов, блоков)
  несущих определенный алгоритм обработки и связей между ними. Связи представляют из себя каналы передачи данных. Также обычно модели потоков данных
  допускаю вложенные подпотоки и содержат некие стратегии запуска.
  Сама концепция потоков данных популярна в научных кругах и часто используется для задач с большими объемами данных и сложными распределенными системами
  благодаря понятности и простоте создания алгоритмов и изоляции от технических деталей распределенной системы и особенностей вычислений в ней.
  Рассмотрим способы представления потоков данных. Среди часто используемых можно выделить такие как:
  \begin{itemize}
    \item декларативные языки программирования (концепция которых очень близка к концепции потоков данных),
    \item графы (самый популярный способ представления из-за наглядной графической нотации),
    \item сети Петри (которые являются подклассом графов, особенно распространены для представления родственной концепции потоков работ),
    \item сети пороцессов Кана (используются для описания алгоритмов потоковой обработки).
  \end{itemize}
  
  В нашей модели используется представление в виде графа. Весь поток данных представляется в виде четверки:
  \begin{itemize}
    \item $B$ --- множество блоков,
    \item множество $E$ задает связи или кналы передачи данных,
    \item множества $I$ и $O$ описывают собственные входные и выходные порты потока данных подобно блоку.
  \end{itemize}
  
  Блок в нашей модели также представляется в виде кортежа:
  \begin{itemize}
    \item наборы $I$ и $O$ входных и выходных портов блока,
    \item $FA$ --- конечный автомат Мили.
  \end{itemize}
  
  В реальных системах построения и запуска потоков данных каждый блок несет детерминированный алгоритм обработки данных,
  однако во время статического анализа данные недоступны, поэтому алгоритм блока в нашей модели описывается автоматом Мили, 
  который показывает лишь качественное поведение блока --- он содержит набор характерных состояний, ребра автомата показывают
  по какому набору портов блоку требуются данные и что блок выдаст в результате работы.
  Опять же из-за недоступности конкретных данных, автомат Мили несколько отличается от классического определения, в частности он может быть недетерминированным и
  часто не полным. Входной и выходной алфавиты соответственно множество подмножеств входных и выходных портов.
  
  На слайде Вы можете видеть графическую нотацию блоков автомата Мили и всего потока данных.
  На первом слайде нарисован блок отвечающего за цикл и его автомат Мили.
  Поясним принцип автомата Мили этого блока.
  Состояние initial соответствует отсутствию внутреннего состояния алгоритма блока.
  Состояние non\_trivial соостветствует промежуточному состоянию --- блок находится в процессе итерации.
  Переход из initial в initial отвечает за пустой список для преобразования.
  Переход из начального состояния в состояние итерации соответствует началу работы, то есть первой итерации.
  При этом блок поглащает сам список и выдает его первый элемент.
  Далее в состоянии итерации блок ожидает преобразованное значение и соответственно может выйти из цикла, излучив результат,
  либо продолжить итерацию в зависимости от длины остаточного списка.
  
  На следующем слайде показан иерархический поток данных. Для удобства введены два фиктивных блока --- source и stock, которые соответствуют
  входным и выходным портам потока данных. Внутри рамочки выделен подпоток данных.
  
  Теперь о работе самого потка данных. В процессе работы потока данных, любой блок может находиться в одном из трех состояний:
  \begin{itemize}
    \item свободен --- означает, что блоку не хватает данных для начала работы;
    \item работает,
    \item заблокирован.
  \end{itemize}
  В нашей модели для простоты все связи могут хранить не более одного набора данных, поэтому завершивший свою работу блок переходит в состояние заблокирован,
  если он не может излучить результат своей работы. Он продолжает находиться в этом состоянии ровно до тех пор, пока не может полностью излучить данные.
  На слайде можно видеть схему работы каждого блока. Ребра соответствуют соответствующим условиям переходов.
  
  Алгоритм работы всего потока данных можно видет на слайде.
  В начале работы система управления опрашивает каждый блок, чтобы узнать необходимые наборы данных для запуска.
  Далее данные передаются необходимым блокам и осуществляется проверка на возможность перевода блока из состояния заблокирован.
  Так система управления разрешает состояния блокировки, далее ожидает окончания работы какого-либо блока, затем процедура повторяется.
  Поток данных завершается, если все блоки свободны и данные остались только на выходных портах потока данных.
  
  Такая модель потоков данных является довльно гибкой и удобной для описания вычислений, однако она допускает неопределенности в своей работе.
  Некоторые неопределенности связаны с заменой алгоритмов блоков на автоматы Мили. Так в реальных запусках такие неопределенности отсутствуют, так
  как данные однозначно определяют поведение потока в этом случае. Такие неопределенности будем называть неопределенности первого рода.
  
  Однако сама схема может так же допускать неопределенности, такие как неколько способов поглощения одного и того же набора данных,
  состояния гонок, также к неопределенностям отнесем возможность некорректного завершения потока данных. Такие неопределенности будем называть
  неопределенностями второго рода и будем считать их наличие ошибкой построения схемы, так как при их наличии в зависимости от обстоятельств запуска поведение и соответствено результат
  всего потока может различаться от запуска к запуску. Поэтому поток данных содержащий такие ошибки нуждается в исправлении, а его анализ лишен смысла.
  
  Корректным потоком данных будем называть поток, схема которого не допускает неопределенностей второго рода.
  
  Для начала введем понятие траектории запуска потока данных. В зависимости от времен затраченных блоками для работы и вариантов разрешения неопределенностей первого рода,
  поток данных будет вести себя различным образом. Траектория --- последовательность состояний потока данных во все моменты модельного времени при определенных
  временах работы блоков и способе разрешения неопределенностей. Каждая траектория пораждает так называемый граф причинности или граф задач.
  Таким образом все возможные траектории разбиваются на классы эквивалентности. При корректном потоке данных, каждый класс определяется лишь способом
  разрешения неопределенностей и содержит траектории со всевозможными наборами времен работы блоков.
  
  На этом факте основан предлагаемый волновой алгоритм.
  В работе представлены два варианта этого алгоритма: простой для случая корректных ациклических потоков данных и алгоритм для общего случая корректных потоков данных.
  На первом слайде приведена словестная формулировка простого алгоритма. Сам алгоритм представляет из себя моделирование работы потока данных,
  учитывающий все неопределенности. Алгоритм представлен в виде рекурсивной функции, на вход которой подается в том числе и частичный граф причинности, который
  алгоритм достраивает в зависимости от варианта разрешения неопределенностей. В результате, начальный запуск функции вернет множество всех возможным графов причинности.
  
  Волновой алгоритм для общего случая отличается способом разрешения циклов --- для того строится внутренний автомат потока данных. Алгоритм также представляется в виде
  рекусивной функции, которая проверяет, наличие в промежуточном внутреннем автомате вершины соответствующей обрабатываемому состоянию потоку данных.
  
  Изначально рассматривалась возможность введения в автомате Мили распределений вероятностей переходов и времен их работы.
  Однако пример, часто использующийся на практике, изображенный на слайде показывает, что данный подход приводит к плохим результатам. Для этого достаточно рассмотреть
  произвольное распределение на переходах автомата Мили блока цикла. Формула для мат. ожидания длины цикла, которое определяет время работы всего потока данных,
  приведена на слайде. Однако на практике типичный диапазон длин может охватыват несколько порядков, что говорит о бессмысленности рассмотрения подобных оценок.
  
  Поэтому было принято решение отказаться от введения распределений вероятностей и следовать подходу, напоминающему минимаксный метод оценивания.
  Для анализа ресурсов требуемых потоком данных, требуется рассмотрение всех графов причинности, которые и описывают вариант поведения потока данных.
  Для простоты будем считать, что поток данных выполняется в гомогенной распределенной среде, а один блок для работы требует оин вычислитель.
  Заметим, что алгоритм использующийся для анализа позволяет отказаться от этих предположений.
  Для оценки ресурсов будем рассматривать так называемые срезы графа причинности и эволюции графа причинности --- множество независимых задач и их
  последовательные связанные цепочки.
  Каждой возможной эволюции графа причинности поставим в соответствие максимальную мощность среза. Эта величина будет определять максимальную загруженность.
  Соотвественно для графа причинности можно получить минимум и максимум этих оценок.
  
  Данные оценки можно получить с помощью алгоритма HEFT.
  
  В большинстве прикладых потоков данных оценки дают малый разброс, однако в ряде специальных случаев дают разброс может быть существенным.
  Для решения этой проблемы предлагается метод динамического уточнения оценок.
  Не трудно заметить, особенно из волнового алгоритма, что многие графы причинности имеют общий подграф, соответствующий началу работы.
  Фактически волновой алгоритм строит префиксное дерево графов причинности, так как каждый рекурсивный вызов функции волнового алгоритма достраивает граф в зависимости от
  варианта разрешения неопределенностей. Метод динамического уточнения основывается на вычислении упомянутых оценок в вершинах этого дерева для остаточных графов.
  Для примера рассмотрим поток данных изображенный на рисунке. Для этого потока возможны три графа причинности, которые соответствуют ветвям условных переходов.
  На графике видны изменения все четырех оценок ресурсов в зависимости от модельного шага, в случае если реализовывается второй граф причинности.
  
  Все рассмотренные алгоритмы и соответственно оценки верны только для корректных потоков данных. Они допускают расширение на случай некорректных потоков данных,
  однако, как уже было сказано, такие потоки нуждаются скорее в исправлении, нежели анализе.
  Рассмотрим теперь задачу проверки потока данных на корректность. В волновых алгоритмах уже были неявно рассотренны
  случаи некорректного завершения и вариантов поглощения данных, поэтому нас будет интересовать задача обнаружения состояний гонок.
  Существует два типа состояний гонок: изменение набора входных портов при поглощении и наличие вариантов поглощения из одного порта.
  Для обнаружения этих типов состояний гонок была рассмотренна модификация волнового алгоритма, заключающаяся в процедуре проверки при каждом поглощении данных.
  Эта процедура осуществляет проверку на наличие неопределенностей по истории поглощений из портов блока. Также вводится история волны, которая реализует проверку на корреляцию волн ---
  волны считаются коррелирующими, если одна является потомком другой. Некоррелирующие волны считаются конкурирующими и именно они могут изменять порядок поглощения
  при изменении времен работы блоков.
  
  Отдельно стоит рассмотреть класс блоков, автоматы Мили которых являются детерминированными по входу, или, другими словами, для которых в каждом состонии существуют переходы только
  по одному набору входных портов. Так этот класс автоматов Мили автоматически исключает состояние гонки, связанное с различными вариантами поглощения.
  Любой алгоритм блока можно модифицировать таким образом, что его автомат Мили станет детерминированным по входу. Однако часто это пораждает неудобства при построении потока данных.
  Для примера можно рассмотреть модификацию блока аппроксиматора. Обычно процесс аппроксимация преставляется двумя блоками: одни строит модель, второй получает на вход модель
  и вычисляет аппроксимированные значения в подаваемых точках. На слайде изображено два варианта автоматов блока. Недетерминированный вариант алгоритма в состоянии with\_model
  мог принимать как новую точку, так и новую модель. Для преведения к детерминированному виду потребовалось ввести дополнительный порт action, который определяет следующее действие:
  ожидание новой точки, либо новой модели. Из рисунка видно, что автомат заметно усложнился, а новый принцип его работы вносит дополнительные трудности в построении потока данных.
  Заметим, что подобным образом можно преобразовать любой алгоритм блока к детерминированному виду.
  
  На этом моя дипломная работа завершается.
  В результате проделанной работы была построенна модель потоков данных, основной особенностью которой была замена алгоритма блока на автомат Мили,
  качественно описывающий поведение блока.
  Далее модель была исследована, были выявлены все случаи неопределенностей --- одни являются следствием упрощения описания блока, другие возникают из-за ошибок
  построения схемы потока данных.
  Далее были предложены алгоритмы нахождения графов причинности, каждый из которых полностью описывают поведение потока в одном случае. По этим
  графам были найдены оценки для необходимого количества вычислителей для наилучшего запуска потока данных в распределенной среде.
  Также был предложен метод динамической корректировки этих оценок в процессе работы потока данных.
  Также была рассмотрена задача проверки потока данных на корректность.
  
  В процессе работы были выявлены следующие возможные дальнейшие исследования:
  \begin{itemize}
    \item Введение более сложной системы оценки времен работы и вероятностей переходов блоков, которая возможно даст положительные результаты.
          Однин из возможных вариантов --- введение характеристических чисел для данных и правила их преобразования блоками.
    \item В процессе работы рассматривалась идея оценки наилучших параметров запуска путем автоматической кластеризации блоков для создания многоуровневой иерархии.
          Один из возможных вариантов --- создание шаблонов составных блоков и поиск по ним.
    \item Также возможны модификации самой модели потоков данных.
    \item Возможно расширение алгоритмов для анализа поведения потоков данных в гетерогенных средах.
    \item В этой работе частично рассматривалась идея ограничения классов автоматов для конкретного класса. Также возможно ограничение на наборы используемых атомарных блоков,
          с целью получения потоков, с определенными свойствами.
  \end{itemize}
  
  The End.
\end{document}