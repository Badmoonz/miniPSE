\documentclass[a4paper,14pt]{article}
\usepackage{amsmath,amsfonts,amssymb,amsthm,epsfig,epstopdf,titling,url,array}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
%\usepackage[T2A]{fontenc}
\usepackage{amsmath,amssymb,amsthm,amscd,amsfonts,graphicx}
\usepackage[14pt]{extsizes}

\begin{document}

\textwidth 15.5cm
\topmargin -1cm
\parindent 1cm
\textheight 24cm
\parskip 1.5mm

\Large
\section{Введение}
\begin{enumerate}
\item[•] В работе workflow представляется блок-ориентированной моделью, в соответствии с используемой в PSE.
\item[•] В принятой модели абстрагируемся от типов передаваемых данных, считая, что при передаче от блока к блоку они консистентны.
\item[•] Время работы каждого блока, мы считаем конечным, но неизвестным.
\item[•] Принятая модель похожа на модель используемую в Kepler (Ptolemy II),в которой применяется Director/Actor парадигма.

\item[•]Главным отличаем Kepler является то, что проектировщик workflow вынужден ставить в соответствие каждому actor'у director( определяющий модель вычислений), управляющий их взаимодействием, порядком запуска,но накладывающий на них ряд ограничений.
\end{enumerate}
\newpage
\section{Цели}
\textit{В своей же работе я хочу автоматизировать выработку стратегий запуска, что снимет с пользователя часть работы по проектированию и потенциально увеличит эффективность работы workflow.}
\newpage
\section{План}
\begin{enumerate}
\item[•] Описание модели workflow
\item[•] Описание 2Wave алгоритма для анализа workflow
\item[•] Алгоритм группировки блоков
\item[•] Возможные ошибки работы workflow
\item[•] Построение оптимальных стратегий запуска
\end{enumerate}

\newpage
\section{Описание модели workflow}
\subsection{Блоки}
\begin{enumerate}
\item[•] Блок – вычислительный компонент workflow 
\item[•] Логика поведения блока представляется моделью недетерминированного конечного автомата(Finite State Machine, FSM)
\item[•] Блоки взаимодействует с другими блоками в workflow через порты
\item[•] Состовной(composite) блок – блок, представляющий композицию несколькоих соединённых блоков
\item[•] Составные блоки могут быть вложенными друг в друга
\item[•] Для составного блока может быть рассчитана стратегию запуска блоков внутри себя 
\item[•] Составные блоки первоначально не имеют конечного автомата, но он может быть рассчитан
\end{enumerate}

\newpage
\subsection{FSM представление блока}
Блока задаётся недетерминированным конечным автоматом ( Finite State Machine, FSM)\\
\textbf{Определение:} конечным автоматом называется набор $ M = (S, \Sigma,\Lambda, T, s_{0})$ , где
\begin{enumerate}
\item[-] S -набор конечных состояния,
\item[-] $\Sigma$ – набор входных портов блока,
\item[-] $\Lambda$ - набор возможных выходных портов блока
\item[-] $s_{0} \in S$ - начальное состояние,
\item[-] $T: S \times 2^{\Sigma} \rightarrow  2^{S \times 2^{\Lambda}}$ отображение, сопоставляющее каждому состоянию с набором входных портов набор состояний с соответствующим набором выходных портов
\end{enumerate}
Диаграма переходов для блока типа `Map`:
\\
\includegraphics[width=120mm]{map.png}


\newpage
\subsection{Граф связей}
Граф связей является ориентированного мультиграфом, где вершины - это блоки, а рёбра - соединения между портами блоков.\\
\textbf{Пример:}\\
\includegraphics[width=180mm]{connection.png}

\subsection{Составной блок}
Составной блок задаётся графом связей включённых в него блоков.%и конечным автоматом(на начальном этапе конечный автомат для составного блока неизвестен, он будет рассчитыван в процессе работы).
\\
Свойства:
\begin{enumerate}
\item[•] Граф связей любого составного блока включает в себя виртуальные блоки  Source и Stock. Source имеет только выходные порты,  Stock  - только входные.
\item[•] more
\end{enumerate}

\newpage
\section{Кластеризация}
Кластеризация - выделение группы блоков и объединение их в составной блок.
\\
Применяется для:
\begin{enumerate}
\item[•] Для уменьшения числа возможных повторяющихся рассчётов в сложных workflow.
\item[•] Выявление стратегии запуска для выделенной группы блоков.
\end{enumerate}

\newpage
\section{2Wave-алгоритм}
\begin{enumerate}
\item[•] Алгоритм прогона модели workflow.
\item[•] Может применяться к любому составному блоку.
\item[•] На выходе выдаёт направленный граф \textit{ состояний workflow} для состовного блока, к которому применяется
\item[•] Алгоритм в ходе работы выявляет возможные ошибки работы workflow.
\item[•] Граф \textit{состояний workflow} в дальнейшем будет использоваться для рассчёта конечного автомата составного блока и анализа для нахождения оптимальной стратегии запуска внутренних блоков. 
\end{enumerate}

\subsection{Cостояние workflow}
Cостояние workflow задаётся парой $(G, BS, W)$, где
\begin{enumerate}
\item G - граф связей состовного блока
\item BS - текущие состояния всех блоков графа
\item W - набор рёбер соответствующего графа связей, выходные порты которых имеют данные
\end{enumerate}

\newpage
\section{Возможные ошибки}
Основными возможными ошибками работы workflow, которые можно обнаружить на этапе проектирования, являются:
\begin{enumerate}
\item[•] \textit{Гонка за запуск по порту (Block Port Race condition)} - блок получает данные на один и тот-же порт  из нескольких конкурирующих источников.
\item[•] \textit{Гонка за состояние(Block State Race condition)} - блок получает данные по набору портов, позволяющем запустить блок по разным [Approx]
\item[•] \textit{Голодание(Starving)}. В workflow к концу его работы могут остаться блоки, имеющие неполный набор портов с данными для запуска
\end{enumerate}
\newpage
\subsection{Гонка за запуск по порту}
Может нарушится очерёдность данных.
Пример:\\
\includegraphics[width=180mm]{raceCondition.png}
Бросается исключение. 
\newpage
\subsection{Гонка за состояние}
Потенциально возможно в блоках, у которых есть состояния
$b = (S, \Sigma,\Lambda, T, s_{0});\\
 \exists s \in S , \exists in1, in2 \in 2^{\Sigma} :  T(s, in1) \neq \varnothing \bigwedge T(s, in2) \neq \varnothing$

Пример такого блока  - Approx.Player, получающий модель и x на вход в конкурирующем режиме.

Конкурирующего режима можно избежать, используя регулирующие блоки.


\subsection{Голодание}
Неопасно. Бросается в конце работы workflow, уведомляя, что остались необработанные данные.

\newpage
\section{Построение оптимальных стратегий запуска}
Условия:
\begin{enumerate}
\item Блок находящийся не в  начальном состоянии $s \neq s_{0}$ нельзя перенести запустить на другом узле(node)
\item На одном узле одновременно может выполняться только один блок
\end{enumerate}
Критерии оптимальности:
\begin{enumerate}
\item[•] Минимальное количество узлов необходимое для максимальной производительности.
\end{enumerate}

\end{document}
